<!DOCTYPE html>
<html>
<head>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8"/>

<title> %\VignetteEncoding{UTF-8}</title>

<script type="text/javascript">
window.onload = function() {
  var imgs = document.getElementsByTagName('img'), i, img;
  for (i = 0; i < imgs.length; i++) {
    img = imgs[i];
    // center an image if it is the only element of its parent
    if (img.parentElement.childElementCount === 1)
      img.parentElement.style.textAlign = 'center';
  }
};
</script>

<!-- Styles for R syntax highlighter -->
<style type="text/css">
   pre .operator,
   pre .paren {
     color: rgb(104, 118, 135)
   }

   pre .literal {
     color: #990073
   }

   pre .number {
     color: #099;
   }

   pre .comment {
     color: #998;
     font-style: italic
   }

   pre .keyword {
     color: #900;
     font-weight: bold
   }

   pre .identifier {
     color: rgb(0, 0, 0);
   }

   pre .string {
     color: #d14;
   }
</style>

<!-- R syntax highlighter -->
<script type="text/javascript">
var hljs=new function(){function m(p){return p.replace(/&/gm,"&amp;").replace(/</gm,"&lt;")}function f(r,q,p){return RegExp(q,"m"+(r.cI?"i":"")+(p?"g":""))}function b(r){for(var p=0;p<r.childNodes.length;p++){var q=r.childNodes[p];if(q.nodeName=="CODE"){return q}if(!(q.nodeType==3&&q.nodeValue.match(/\s+/))){break}}}function h(t,s){var p="";for(var r=0;r<t.childNodes.length;r++){if(t.childNodes[r].nodeType==3){var q=t.childNodes[r].nodeValue;if(s){q=q.replace(/\n/g,"")}p+=q}else{if(t.childNodes[r].nodeName=="BR"){p+="\n"}else{p+=h(t.childNodes[r])}}}if(/MSIE [678]/.test(navigator.userAgent)){p=p.replace(/\r/g,"\n")}return p}function a(s){var r=s.className.split(/\s+/);r=r.concat(s.parentNode.className.split(/\s+/));for(var q=0;q<r.length;q++){var p=r[q].replace(/^language-/,"");if(e[p]){return p}}}function c(q){var p=[];(function(s,t){for(var r=0;r<s.childNodes.length;r++){if(s.childNodes[r].nodeType==3){t+=s.childNodes[r].nodeValue.length}else{if(s.childNodes[r].nodeName=="BR"){t+=1}else{if(s.childNodes[r].nodeType==1){p.push({event:"start",offset:t,node:s.childNodes[r]});t=arguments.callee(s.childNodes[r],t);p.push({event:"stop",offset:t,node:s.childNodes[r]})}}}}return t})(q,0);return p}function k(y,w,x){var q=0;var z="";var s=[];function u(){if(y.length&&w.length){if(y[0].offset!=w[0].offset){return(y[0].offset<w[0].offset)?y:w}else{return w[0].event=="start"?y:w}}else{return y.length?y:w}}function t(D){var A="<"+D.nodeName.toLowerCase();for(var B=0;B<D.attributes.length;B++){var C=D.attributes[B];A+=" "+C.nodeName.toLowerCase();if(C.value!==undefined&&C.value!==false&&C.value!==null){A+='="'+m(C.value)+'"'}}return A+">"}while(y.length||w.length){var v=u().splice(0,1)[0];z+=m(x.substr(q,v.offset-q));q=v.offset;if(v.event=="start"){z+=t(v.node);s.push(v.node)}else{if(v.event=="stop"){var p,r=s.length;do{r--;p=s[r];z+=("</"+p.nodeName.toLowerCase()+">")}while(p!=v.node);s.splice(r,1);while(r<s.length){z+=t(s[r]);r++}}}}return z+m(x.substr(q))}function j(){function q(x,y,v){if(x.compiled){return}var u;var s=[];if(x.k){x.lR=f(y,x.l||hljs.IR,true);for(var w in x.k){if(!x.k.hasOwnProperty(w)){continue}if(x.k[w] instanceof Object){u=x.k[w]}else{u=x.k;w="keyword"}for(var r in u){if(!u.hasOwnProperty(r)){continue}x.k[r]=[w,u[r]];s.push(r)}}}if(!v){if(x.bWK){x.b="\\b("+s.join("|")+")\\s"}x.bR=f(y,x.b?x.b:"\\B|\\b");if(!x.e&&!x.eW){x.e="\\B|\\b"}if(x.e){x.eR=f(y,x.e)}}if(x.i){x.iR=f(y,x.i)}if(x.r===undefined){x.r=1}if(!x.c){x.c=[]}x.compiled=true;for(var t=0;t<x.c.length;t++){if(x.c[t]=="self"){x.c[t]=x}q(x.c[t],y,false)}if(x.starts){q(x.starts,y,false)}}for(var p in e){if(!e.hasOwnProperty(p)){continue}q(e[p].dM,e[p],true)}}function d(B,C){if(!j.called){j();j.called=true}function q(r,M){for(var L=0;L<M.c.length;L++){if((M.c[L].bR.exec(r)||[null])[0]==r){return M.c[L]}}}function v(L,r){if(D[L].e&&D[L].eR.test(r)){return 1}if(D[L].eW){var M=v(L-1,r);return M?M+1:0}return 0}function w(r,L){return L.i&&L.iR.test(r)}function K(N,O){var M=[];for(var L=0;L<N.c.length;L++){M.push(N.c[L].b)}var r=D.length-1;do{if(D[r].e){M.push(D[r].e)}r--}while(D[r+1].eW);if(N.i){M.push(N.i)}return f(O,M.join("|"),true)}function p(M,L){var N=D[D.length-1];if(!N.t){N.t=K(N,E)}N.t.lastIndex=L;var r=N.t.exec(M);return r?[M.substr(L,r.index-L),r[0],false]:[M.substr(L),"",true]}function z(N,r){var L=E.cI?r[0].toLowerCase():r[0];var M=N.k[L];if(M&&M instanceof Array){return M}return false}function F(L,P){L=m(L);if(!P.k){return L}var r="";var O=0;P.lR.lastIndex=0;var M=P.lR.exec(L);while(M){r+=L.substr(O,M.index-O);var N=z(P,M);if(N){x+=N[1];r+='<span class="'+N[0]+'">'+M[0]+"</span>"}else{r+=M[0]}O=P.lR.lastIndex;M=P.lR.exec(L)}return r+L.substr(O,L.length-O)}function J(L,M){if(M.sL&&e[M.sL]){var r=d(M.sL,L);x+=r.keyword_count;return r.value}else{return F(L,M)}}function I(M,r){var L=M.cN?'<span class="'+M.cN+'">':"";if(M.rB){y+=L;M.buffer=""}else{if(M.eB){y+=m(r)+L;M.buffer=""}else{y+=L;M.buffer=r}}D.push(M);A+=M.r}function G(N,M,Q){var R=D[D.length-1];if(Q){y+=J(R.buffer+N,R);return false}var P=q(M,R);if(P){y+=J(R.buffer+N,R);I(P,M);return P.rB}var L=v(D.length-1,M);if(L){var O=R.cN?"</span>":"";if(R.rE){y+=J(R.buffer+N,R)+O}else{if(R.eE){y+=J(R.buffer+N,R)+O+m(M)}else{y+=J(R.buffer+N+M,R)+O}}while(L>1){O=D[D.length-2].cN?"</span>":"";y+=O;L--;D.length--}var r=D[D.length-1];D.length--;D[D.length-1].buffer="";if(r.starts){I(r.starts,"")}return R.rE}if(w(M,R)){throw"Illegal"}}var E=e[B];var D=[E.dM];var A=0;var x=0;var y="";try{var s,u=0;E.dM.buffer="";do{s=p(C,u);var t=G(s[0],s[1],s[2]);u+=s[0].length;if(!t){u+=s[1].length}}while(!s[2]);if(D.length>1){throw"Illegal"}return{r:A,keyword_count:x,value:y}}catch(H){if(H=="Illegal"){return{r:0,keyword_count:0,value:m(C)}}else{throw H}}}function g(t){var p={keyword_count:0,r:0,value:m(t)};var r=p;for(var q in e){if(!e.hasOwnProperty(q)){continue}var s=d(q,t);s.language=q;if(s.keyword_count+s.r>r.keyword_count+r.r){r=s}if(s.keyword_count+s.r>p.keyword_count+p.r){r=p;p=s}}if(r.language){p.second_best=r}return p}function i(r,q,p){if(q){r=r.replace(/^((<[^>]+>|\t)+)/gm,function(t,w,v,u){return w.replace(/\t/g,q)})}if(p){r=r.replace(/\n/g,"<br>")}return r}function n(t,w,r){var x=h(t,r);var v=a(t);var y,s;if(v){y=d(v,x)}else{return}var q=c(t);if(q.length){s=document.createElement("pre");s.innerHTML=y.value;y.value=k(q,c(s),x)}y.value=i(y.value,w,r);var u=t.className;if(!u.match("(\\s|^)(language-)?"+v+"(\\s|$)")){u=u?(u+" "+v):v}if(/MSIE [678]/.test(navigator.userAgent)&&t.tagName=="CODE"&&t.parentNode.tagName=="PRE"){s=t.parentNode;var p=document.createElement("div");p.innerHTML="<pre><code>"+y.value+"</code></pre>";t=p.firstChild.firstChild;p.firstChild.cN=s.cN;s.parentNode.replaceChild(p.firstChild,s)}else{t.innerHTML=y.value}t.className=u;t.result={language:v,kw:y.keyword_count,re:y.r};if(y.second_best){t.second_best={language:y.second_best.language,kw:y.second_best.keyword_count,re:y.second_best.r}}}function o(){if(o.called){return}o.called=true;var r=document.getElementsByTagName("pre");for(var p=0;p<r.length;p++){var q=b(r[p]);if(q){n(q,hljs.tabReplace)}}}function l(){if(window.addEventListener){window.addEventListener("DOMContentLoaded",o,false);window.addEventListener("load",o,false)}else{if(window.attachEvent){window.attachEvent("onload",o)}else{window.onload=o}}}var e={};this.LANGUAGES=e;this.highlight=d;this.highlightAuto=g;this.fixMarkup=i;this.highlightBlock=n;this.initHighlighting=o;this.initHighlightingOnLoad=l;this.IR="[a-zA-Z][a-zA-Z0-9_]*";this.UIR="[a-zA-Z_][a-zA-Z0-9_]*";this.NR="\\b\\d+(\\.\\d+)?";this.CNR="\\b(0[xX][a-fA-F0-9]+|(\\d+(\\.\\d*)?|\\.\\d+)([eE][-+]?\\d+)?)";this.BNR="\\b(0b[01]+)";this.RSR="!|!=|!==|%|%=|&|&&|&=|\\*|\\*=|\\+|\\+=|,|\\.|-|-=|/|/=|:|;|<|<<|<<=|<=|=|==|===|>|>=|>>|>>=|>>>|>>>=|\\?|\\[|\\{|\\(|\\^|\\^=|\\||\\|=|\\|\\||~";this.ER="(?![\\s\\S])";this.BE={b:"\\\\.",r:0};this.ASM={cN:"string",b:"'",e:"'",i:"\\n",c:[this.BE],r:0};this.QSM={cN:"string",b:'"',e:'"',i:"\\n",c:[this.BE],r:0};this.CLCM={cN:"comment",b:"//",e:"$"};this.CBLCLM={cN:"comment",b:"/\\*",e:"\\*/"};this.HCM={cN:"comment",b:"#",e:"$"};this.NM={cN:"number",b:this.NR,r:0};this.CNM={cN:"number",b:this.CNR,r:0};this.BNM={cN:"number",b:this.BNR,r:0};this.inherit=function(r,s){var p={};for(var q in r){p[q]=r[q]}if(s){for(var q in s){p[q]=s[q]}}return p}}();hljs.LANGUAGES.cpp=function(){var a={keyword:{"false":1,"int":1,"float":1,"while":1,"private":1,"char":1,"catch":1,"export":1,virtual:1,operator:2,sizeof:2,dynamic_cast:2,typedef:2,const_cast:2,"const":1,struct:1,"for":1,static_cast:2,union:1,namespace:1,unsigned:1,"long":1,"throw":1,"volatile":2,"static":1,"protected":1,bool:1,template:1,mutable:1,"if":1,"public":1,friend:2,"do":1,"return":1,"goto":1,auto:1,"void":2,"enum":1,"else":1,"break":1,"new":1,extern:1,using:1,"true":1,"class":1,asm:1,"case":1,typeid:1,"short":1,reinterpret_cast:2,"default":1,"double":1,register:1,explicit:1,signed:1,typename:1,"try":1,"this":1,"switch":1,"continue":1,wchar_t:1,inline:1,"delete":1,alignof:1,char16_t:1,char32_t:1,constexpr:1,decltype:1,noexcept:1,nullptr:1,static_assert:1,thread_local:1,restrict:1,_Bool:1,complex:1},built_in:{std:1,string:1,cin:1,cout:1,cerr:1,clog:1,stringstream:1,istringstream:1,ostringstream:1,auto_ptr:1,deque:1,list:1,queue:1,stack:1,vector:1,map:1,set:1,bitset:1,multiset:1,multimap:1,unordered_set:1,unordered_map:1,unordered_multiset:1,unordered_multimap:1,array:1,shared_ptr:1}};return{dM:{k:a,i:"</",c:[hljs.CLCM,hljs.CBLCLM,hljs.QSM,{cN:"string",b:"'\\\\?.",e:"'",i:"."},{cN:"number",b:"\\b(\\d+(\\.\\d*)?|\\.\\d+)(u|U|l|L|ul|UL|f|F)"},hljs.CNM,{cN:"preprocessor",b:"#",e:"$"},{cN:"stl_container",b:"\\b(deque|list|queue|stack|vector|map|set|bitset|multiset|multimap|unordered_map|unordered_set|unordered_multiset|unordered_multimap|array)\\s*<",e:">",k:a,r:10,c:["self"]}]}}}();hljs.LANGUAGES.r={dM:{c:[hljs.HCM,{cN:"number",b:"\\b0[xX][0-9a-fA-F]+[Li]?\\b",e:hljs.IMMEDIATE_RE,r:0},{cN:"number",b:"\\b\\d+(?:[eE][+\\-]?\\d*)?L\\b",e:hljs.IMMEDIATE_RE,r:0},{cN:"number",b:"\\b\\d+\\.(?!\\d)(?:i\\b)?",e:hljs.IMMEDIATE_RE,r:1},{cN:"number",b:"\\b\\d+(?:\\.\\d*)?(?:[eE][+\\-]?\\d*)?i?\\b",e:hljs.IMMEDIATE_RE,r:0},{cN:"number",b:"\\.\\d+(?:[eE][+\\-]?\\d*)?i?\\b",e:hljs.IMMEDIATE_RE,r:1},{cN:"keyword",b:"(?:tryCatch|library|setGeneric|setGroupGeneric)\\b",e:hljs.IMMEDIATE_RE,r:10},{cN:"keyword",b:"\\.\\.\\.",e:hljs.IMMEDIATE_RE,r:10},{cN:"keyword",b:"\\.\\.\\d+(?![\\w.])",e:hljs.IMMEDIATE_RE,r:10},{cN:"keyword",b:"\\b(?:function)",e:hljs.IMMEDIATE_RE,r:2},{cN:"keyword",b:"(?:if|in|break|next|repeat|else|for|return|switch|while|try|stop|warning|require|attach|detach|source|setMethod|setClass)\\b",e:hljs.IMMEDIATE_RE,r:1},{cN:"literal",b:"(?:NA|NA_integer_|NA_real_|NA_character_|NA_complex_)\\b",e:hljs.IMMEDIATE_RE,r:10},{cN:"literal",b:"(?:NULL|TRUE|FALSE|T|F|Inf|NaN)\\b",e:hljs.IMMEDIATE_RE,r:1},{cN:"identifier",b:"[a-zA-Z.][a-zA-Z0-9._]*\\b",e:hljs.IMMEDIATE_RE,r:0},{cN:"operator",b:"<\\-(?!\\s*\\d)",e:hljs.IMMEDIATE_RE,r:2},{cN:"operator",b:"\\->|<\\-",e:hljs.IMMEDIATE_RE,r:1},{cN:"operator",b:"%%|~",e:hljs.IMMEDIATE_RE},{cN:"operator",b:">=|<=|==|!=|\\|\\||&&|=|\\+|\\-|\\*|/|\\^|>|<|!|&|\\||\\$|:",e:hljs.IMMEDIATE_RE,r:0},{cN:"operator",b:"%",e:"%",i:"\\n",r:1},{cN:"identifier",b:"`",e:"`",r:0},{cN:"string",b:'"',e:'"',c:[hljs.BE],r:0},{cN:"string",b:"'",e:"'",c:[hljs.BE],r:0},{cN:"paren",b:"[[({\\])}]",e:hljs.IMMEDIATE_RE,r:0}]}};
hljs.initHighlightingOnLoad();
</script>



<style type="text/css">
body, td {
   font-family: sans-serif;
   background-color: white;
   font-size: 13px;
}

body {
  max-width: 800px;
  margin: auto;
  padding: 1em;
  line-height: 20px;
}

tt, code, pre {
   font-family: 'DejaVu Sans Mono', 'Droid Sans Mono', 'Lucida Console', Consolas, Monaco, monospace;
}

h1 {
   font-size:2.2em;
}

h2 {
   font-size:1.8em;
}

h3 {
   font-size:1.4em;
}

h4 {
   font-size:1.0em;
}

h5 {
   font-size:0.9em;
}

h6 {
   font-size:0.8em;
}

a:visited {
   color: rgb(50%, 0%, 50%);
}

pre, img {
  max-width: 100%;
}
pre {
  overflow-x: auto;
}
pre code {
   display: block; padding: 0.5em;
}

code {
  font-size: 92%;
  border: 1px solid #ccc;
}

code[class] {
  background-color: #F8F8F8;
}

table, td, th {
  border: none;
}

blockquote {
   color:#666666;
   margin:0;
   padding-left: 1em;
   border-left: 0.5em #EEE solid;
}

hr {
   height: 0px;
   border-bottom: none;
   border-top-width: thin;
   border-top-style: dotted;
   border-top-color: #999999;
}

@media print {
   * {
      background: transparent !important;
      color: black !important;
      filter:none !important;
      -ms-filter: none !important;
   }

   body {
      font-size:12pt;
      max-width:100%;
   }

   a, a:visited {
      text-decoration: underline;
   }

   hr {
      visibility: hidden;
      page-break-before: always;
   }

   pre, blockquote {
      padding-right: 1em;
      page-break-inside: avoid;
   }

   tr, img {
      page-break-inside: avoid;
   }

   img {
      max-width: 100% !important;
   }

   @page :left {
      margin: 15mm 20mm 15mm 10mm;
   }

   @page :right {
      margin: 15mm 10mm 15mm 20mm;
   }

   p, h2, h3 {
      orphans: 3; widows: 3;
   }

   h2, h3 {
      page-break-after: avoid;
   }
}
</style>



</head>

<body>
<hr/>

<p>title: &ldquo;Creating Linear Regression Matrices from Segment data&rdquo;
author: &ldquo;James Dalgleish&rdquo;
date: &ldquo;July 25, 2018&rdquo;
output: rmarkdown::html_vignette
vignette: &gt;
 %\VignetteEngine{knitr::rmarkdown}
 %\VignetteIndexEntry{Linear Regression/Postprocess}</p>

<h2> %\VignetteEncoding{UTF-8}</h2>

<p>From our previous work, we created a small input matrix, with segmented 1Mb regions as our row labels and with sample names from TARGET data as our column labels.
We can read that in using the following code:</p>

<pre><code class="r">library(HiCNV)
</code></pre>

<pre><code class="r">nbl_input_matrix[1:5,1:5]
</code></pre>

<pre><code>##                      PASEGA   PASRFS   PARHYL   PARVME PATGJU
## chr1_1_1000000         0.77 1.226667 0.990000 1.304444   1.09
## chr1_1000001_2000000   0.77 1.000000 1.053333 1.180000   1.09
## chr1_2000001_3000000   0.77 1.000000 0.850000 1.000000   1.09
## chr1_3000001_4000000   0.77 1.000000 0.850000 1.000000   1.09
## chr1_4000001_5000000   0.77 1.000000 0.850000 1.000000   1.09
</code></pre>

<p>calcVecLMs() comes standard in the HiCNV package. It allows calculation of the matrix with parallel processing using mclapply, but larger matrices will require a bit more power, and thus we use slurm_apply, from the rslurm pacakge to distribute the work over multiple cores. Our particular establishment has a limit approximating 1000 jobs, so it&#39;s best not to use more than that unless your cluster will support it. Conversely, you should use less if you can&#39;t submit that many individual jobs in a job array in your cluster. In this particular example, I&#39;ve removed rows where there is no segmentation data, across the board using colSums().</p>

<pre><code class="r">library(parallel)
nbl_slurm_object_test_zero_removed&lt;-calcVecLMs(bin_data =as.data.frame(t(nbl_input_matrix[which(rowSds(as.matrix(nbl_input_matrix))!=0.0),])),use_slurm = T,n_nodes = 975,memory_per_node = &quot;32g&quot;,walltime = &quot;04:00:00&quot;,cpus_on_each_node = 2,job_finished = F,slurmjob = NULL)
</code></pre>

<p>Saving the slurm object is essential as it will be required when you retrieve your results.</p>

<pre><code class="r">saveRDS(nbl_slurm_object_test_zero_removed,&quot;nbl_slurm_object_test_zero_removed.rds&quot;)
</code></pre>

<p>Retrieving the data is as simple as using rslurm::get_slurm_out() on the saved slurm object and coercing it into a matrix with the original number of columns. The slurm object must have been read with readRDS() previously or done in the same session. For the purposes of making this tutorial, we have chosen to work on a small version of the whole matrix to make 5MB CRAN documentation limits. Previous versions of the tutorial included the whole matrix, but we leave that to the user to construct at this point. For reproducibility, one can find the original full data matrix at <a href="https://github.com/jamesdalg/CNScope_public_data">https://github.com/jamesdalg/CNScope_public_data</a>.</p>

<pre><code class="r">library(matrixStats)
nbl_result_matrix&lt;-matrix(as.numeric(unlist( get_slurm_out(nbl_slurm_object_test_zero_removed))),ncol=ncol(as.data.frame(t(nbl_input_matrix[which(rowSds(as.matrix(nbl_input_matrix))!=0.0),])) ) )

saveRDS(nbl_result_matrix,&quot;nbl_result_matrix_full.rds&quot;)
saveRDS(nbl_result_matrix[1:25,1:25],&quot;nbl_result_matrix_small.rds&quot;)
</code></pre>

<p>You&#39;ll notice that there are no signs in this matrix (they&#39;re just negative log p-values, which are always positive). We&#39;ll have to assign signs by the correlation matrix next, then we will chunk the large matrix into smaller, flattened matrices that the shiny app can handle. For lower capacity machines/clusters, an alternative may be using the cor function.</p>

<p>In order to perfrom sign correction,fix the &ldquo;Inf values&rdquo; to a viewable value, and restore column and row names, postProcessLinRegMatrix() can be applied, yielding a final full matrix of the entire genome (Chr1-&gt;ChrX on both Axes).  300 has been used, although something a bit smaller will reduce saturation issues depending on the disparity between the lowest values in the matrix and 300.
We&#39;ll plot the result below, using complexheatmap and a custom designed function that takes large asymmetric distributions of values and pushes them into the [0,1] colorspace with white at 0.5, corresponding to zero, values between 0 and 0.5 corresponding to negative values, and values from 0.5 to 1 corresponding to positive values (signedRescale).</p>

<pre><code class="r">nbl_result_matrix_small&lt;-readRDS(&quot;nbl_result_matrix_small.rds&quot;)
nbl_result_matrix_small[1:5,1:5]
</code></pre>

<pre><code>##          [,1]       [,2]       [,3]       [,4]       [,5]
## [1,]      Inf   4.766959   3.743363   3.800939   3.800939
## [2,] 4.766959        Inf 199.883186 176.388907 176.388907
## [3,] 3.743363 199.883186        Inf 299.519384 299.519384
## [4,] 3.800939 176.388907 299.519384        Inf        Inf
## [5,] 3.800939 176.388907 299.519384        Inf        Inf
</code></pre>

<pre><code class="r">nbl_result_matrix_sign_corrected&lt;-postProcessLinRegMatrix(input_matrix = nbl_input_matrix[1:25,1:25],LM_mat = nbl_result_matrix_small,cor_type = &quot;pearson&quot;,inf_replacement_val = 300)
nbl_result_matrix_sign_corrected[1:5,1:5]
</code></pre>

<pre><code>##                      chr1_1_1000000 chr1_1000001_2000000
## chr1_1_1000000           300.000000             4.766959
## chr1_1000001_2000000       4.766959           300.000000
## chr1_2000001_3000000       3.743363           199.883186
## chr1_3000001_4000000       3.800939           176.388907
## chr1_4000001_5000000       3.800939           176.388907
##                      chr1_2000001_3000000 chr1_3000001_4000000
## chr1_1_1000000                   3.743363             3.800939
## chr1_1000001_2000000           199.883186           176.388907
## chr1_2000001_3000000           300.000000           299.519384
## chr1_3000001_4000000           299.519384           300.000000
## chr1_4000001_5000000           299.519384           300.000000
##                      chr1_4000001_5000000
## chr1_1_1000000                   3.800939
## chr1_1000001_2000000           176.388907
## chr1_2000001_3000000           299.519384
## chr1_3000001_4000000           300.000000
## chr1_4000001_5000000           300.000000
</code></pre>

<pre><code class="r">nbl_result_matrix_sign_corrected[1:5,1:5]
</code></pre>

<pre><code>##                      chr1_1_1000000 chr1_1000001_2000000
## chr1_1_1000000           300.000000             4.766959
## chr1_1000001_2000000       4.766959           300.000000
## chr1_2000001_3000000       3.743363           199.883186
## chr1_3000001_4000000       3.800939           176.388907
## chr1_4000001_5000000       3.800939           176.388907
##                      chr1_2000001_3000000 chr1_3000001_4000000
## chr1_1_1000000                   3.743363             3.800939
## chr1_1000001_2000000           199.883186           176.388907
## chr1_2000001_3000000           300.000000           299.519384
## chr1_3000001_4000000           299.519384           300.000000
## chr1_4000001_5000000           299.519384           300.000000
##                      chr1_4000001_5000000
## chr1_1_1000000                   3.800939
## chr1_1000001_2000000           176.388907
## chr1_2000001_3000000           299.519384
## chr1_3000001_4000000           300.000000
## chr1_4000001_5000000           300.000000
</code></pre>

<pre><code class="r">ComplexHeatmap::Heatmap(signedRescale(as.matrix(nbl_result_matrix_sign_corrected)),col = circlize::colorRamp2(c(0,0.5,1),c(&quot;blue&quot;,&quot;white&quot;,&quot;red&quot;)),cluster_rows = F,cluster_columns = F,show_heatmap_legend = F,show_column_names = F,show_row_names = F)
</code></pre>

<p><img src="data:image/png;base64,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" alt="plot of chunk unnamed-chunk-9"/>
Finally, the whole genome matrix is too big to plot interactively without crashing most browsers using the plotly package. We&#39;ll need to break things apart a bit. A final function will write chromosomal pair heatmaps to disk with genes from ensembl (hg19 coordinates) in encoded for each square in the matrix. Please only use this function on the WHOLE matrix, not on the small subset we have provided in documentation.</p>

<pre><code class="r">if(!dir.exists(&quot;nbl_matrix_set&quot;)){dir.create(&quot;nbl_matrix_set&quot;)}
#setwd(&quot;nbl_matrix_set&quot;)
doMC::registerDoMC()
#use ONLY the whole matrix with chromosomes 1-X, not the small subset provided for documentation purposes.
createChromosomalMatrixSet(whole_genome_mat=nbl_result_matrix_sign_corrected,output_dir=&quot;nbl_matrix_set&quot;,prefix=&quot;nbl_&quot;)
</code></pre>

<pre><code class="r">list.files(&quot;nbl_matrix_set&quot;)
</code></pre>

<p>There should be 529 of these particular files upon running the code. If there are not, don&#39;t hesitate to run the code again. It can happen on a cluster. It is built to detect when chromosomal matrix is already written to disk.</p>

</body>

</html>
